
-- ↓ここから第三回↓
-- import Data.List

myisPrefixOf [] _ = True
myisPrefixOf _ [] = False
myisPrefixOf (x:xs) (y:ys) = (x == y) && (myisPrefixOf xs ys)

type Variable = String
data Term = Var Variable | App Term Term | Lam Variable Term  deriving (Show, Eq)
data Status = Complete Term | Incomplete [Status] | Waiting String

bracketStart = "("
bracketEnd   = ")"
lambdaStart  = "\\"
lambdaEnd    = "."

getStrUntilFirstX :: String -> String -> String
getStrUntilFirstX x []  = []
getStrUntilFirstX x str = if isPrefixOf x str then [] else (head str):getStrUntilFirstX x (tail str)

getStrFromFirstX :: String -> String -> String
getStrFromFirstX x []  = []
getStrFromFirstX x str = if isPrefixOf x str then dropX x str else getStrFromFirstX x (tail str)

splitWithFirstX :: String -> String -> (String, String)
splitWithFirstX x str = (getStrUntilFirstX x str, getStrFromFirstX x str)

stripl :: String -> String
stripl (' ':xs) = stripl xs
stripl xs       = xs

stripr :: String -> String
stripr = reverse . stripl . reverse

strip :: String -> String
strip = stripl . stripr

spaceBefore :: String -> String -> String
spaceBefore x "" = ""
spaceBefore x (sh:st) = if x `isPrefixOf` (sh:st) then ' ':sh:spaceBefore x st else sh:spaceBefore x st

compress :: String -> String
compress ""           = ""
compress (x1:[])      = x1:[]
compress (x1:(x2:xs)) = if x1 == ' ' && x2 == ' ' then x2:xs else x1:compress (x2:xs)

dropX x str = drop (length x) str

findArgs :: String -> Term -> Term
findArgs raw =
  case strip raw of
    ""  -> id
    str -> (Lam (getStrUntilFirstX " " str)) . findArgs (getStrFromFirstX " " str)


stringToTerm :: String -> Maybe Term
stringToTerm str = 
  let (mt,s) = readStr str
  in if s == "" then joinTerms mt else Nothing

joinTerms :: [Maybe Term] -> Maybe Term
joinTerms []         = Nothing
joinTerms (t1:[])    = t1
joinTerms (t1:t2:ts) = joinTerms $ ((App<$>t1<*>t2) : ts)

joinResult r (lr,ll) = (r:lr, ll)

readStr :: String -> ([Maybe Term], String)
readStr raw = 
    let str     = compress $ strip
                  $ spaceBefore bracketStart 
                  $ spaceBefore bracketEnd 
                  $ spaceBefore lambdaStart 
                  $ spaceBefore lambdaEnd 
                  $ raw
    in  if str == ""
        then ([],"")
        else
          if bracketStart `isPrefixOf` str
          then (\(r, l) -> joinTerms r `joinResult` readStr l) $ readStr (dropX bracketEnd str)
          else 
            if bracketEnd `isPrefixOf` str
            then ([], dropX bracketStart str)
            else
              if lambdaStart `isPrefixOf` str
              then let  args = findArgs $ getStrFromFirstX lambdaStart $ getStrUntilFirstX lambdaEnd str
                        (leftResult, leftLeft) = readStr $ getStrFromFirstX lambdaEnd str
                    in  ((args <$> head leftResult) : tail leftResult, leftLeft)
              else (Just $ Var $ getStrUntilFirstX " " str) `joinResult` readStr (getStrFromFirstX " " str)

termToString term =
  case term of
    Var v -> v
    App a b -> "(" ++ (termToString a) ++ " " ++ (termToString b) ++ ")"
    Lam v t -> "(λ " ++ v ++ ". " ++ (termToString t) ++ ")"

replace x t1 t2 = 
  case t1 of
    Var v   -> if v == x then t2 else Ver v
    App a b -> App (replace x a t2) (replace x b t2)
    Lam v t -> if v == x then Lam v t else Lam v (replace x t t2)

calc term =
  case term of
    App (Lam x t1) t2 -> replace x t1 t2
    App t1 t2         -> replace